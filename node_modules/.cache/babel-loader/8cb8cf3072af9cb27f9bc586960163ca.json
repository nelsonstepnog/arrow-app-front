{"ast":null,"code":"// Generated by CoffeeScript 1.12.6\n\n/*\n   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0\n\n   Copyright (C) 2010-2013 [Jeff Mesnil](http://jmesnil.net/)\n   Copyright (C) 2012 [FuseSource, Inc.](http://fusesource.com)\n   Copyright (C) 2017 [Deepak Kumar](https://www.kreatio.com)\n */\n(function () {\n  var Byte,\n      Client,\n      Frame,\n      Stomp,\n      hasProp = {}.hasOwnProperty,\n      slice = [].slice;\n  Byte = {\n    LF: '\\x0A',\n    NULL: '\\x00'\n  };\n\n  Frame = function () {\n    var unmarshallSingle;\n\n    function Frame(command1, headers1, body1, escapeHeaderValues1) {\n      this.command = command1;\n      this.headers = headers1 != null ? headers1 : {};\n      this.body = body1 != null ? body1 : '';\n      this.escapeHeaderValues = escapeHeaderValues1 != null ? escapeHeaderValues1 : false;\n    }\n\n    Frame.prototype.toString = function () {\n      var lines, name, ref, skipContentLength, value;\n      lines = [this.command];\n      skipContentLength = this.headers['content-length'] === false ? true : false;\n\n      if (skipContentLength) {\n        delete this.headers['content-length'];\n      }\n\n      ref = this.headers;\n\n      for (name in ref) {\n        if (!hasProp.call(ref, name)) continue;\n        value = ref[name];\n\n        if (this.escapeHeaderValues && this.command !== 'CONNECT' && this.command !== 'CONNECTED') {\n          lines.push(name + \":\" + Frame.frEscape(value));\n        } else {\n          lines.push(name + \":\" + value);\n        }\n      }\n\n      if (this.body && !skipContentLength) {\n        lines.push(\"content-length:\" + Frame.sizeOfUTF8(this.body));\n      }\n\n      lines.push(Byte.LF + this.body);\n      return lines.join(Byte.LF);\n    };\n\n    Frame.sizeOfUTF8 = function (s) {\n      if (s) {\n        return encodeURI(s).match(/%..|./g).length;\n      } else {\n        return 0;\n      }\n    };\n\n    unmarshallSingle = function (data, escapeHeaderValues) {\n      var body, chr, command, divider, headerLines, headers, i, idx, j, k, len, len1, line, ref, ref1, ref2, start, trim;\n\n      if (escapeHeaderValues == null) {\n        escapeHeaderValues = false;\n      }\n\n      divider = data.search(RegExp(\"\" + Byte.LF + Byte.LF));\n      headerLines = data.substring(0, divider).split(Byte.LF);\n      command = headerLines.shift();\n      headers = {};\n\n      trim = function (str) {\n        return str.replace(/^\\s+|\\s+$/g, '');\n      };\n\n      ref = headerLines.reverse();\n\n      for (j = 0, len1 = ref.length; j < len1; j++) {\n        line = ref[j];\n        idx = line.indexOf(':');\n\n        if (escapeHeaderValues && command !== 'CONNECT' && command !== 'CONNECTED') {\n          headers[trim(line.substring(0, idx))] = Frame.frUnEscape(trim(line.substring(idx + 1)));\n        } else {\n          headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));\n        }\n      }\n\n      body = '';\n      start = divider + 2;\n\n      if (headers['content-length']) {\n        len = parseInt(headers['content-length']);\n        body = ('' + data).substring(start, start + len);\n      } else {\n        chr = null;\n\n        for (i = k = ref1 = start, ref2 = data.length; ref1 <= ref2 ? k < ref2 : k > ref2; i = ref1 <= ref2 ? ++k : --k) {\n          chr = data.charAt(i);\n\n          if (chr === Byte.NULL) {\n            break;\n          }\n\n          body += chr;\n        }\n      }\n\n      return new Frame(command, headers, body, escapeHeaderValues);\n    };\n\n    Frame.unmarshall = function (datas, escapeHeaderValues) {\n      var frame, frames, last_frame, r;\n\n      if (escapeHeaderValues == null) {\n        escapeHeaderValues = false;\n      }\n\n      frames = datas.split(RegExp(\"\" + Byte.NULL + Byte.LF + \"*\"));\n      r = {\n        frames: [],\n        partial: ''\n      };\n\n      r.frames = function () {\n        var j, len1, ref, results;\n        ref = frames.slice(0, -1);\n        results = [];\n\n        for (j = 0, len1 = ref.length; j < len1; j++) {\n          frame = ref[j];\n          results.push(unmarshallSingle(frame, escapeHeaderValues));\n        }\n\n        return results;\n      }();\n\n      last_frame = frames.slice(-1)[0];\n\n      if (last_frame === Byte.LF || last_frame.search(RegExp(\"\" + Byte.NULL + Byte.LF + \"*$\")) !== -1) {\n        r.frames.push(unmarshallSingle(last_frame, escapeHeaderValues));\n      } else {\n        r.partial = last_frame;\n      }\n\n      return r;\n    };\n\n    Frame.marshall = function (command, headers, body, escapeHeaderValues) {\n      var frame;\n      frame = new Frame(command, headers, body, escapeHeaderValues);\n      return frame.toString() + Byte.NULL;\n    };\n\n    Frame.frEscape = function (str) {\n      return (\"\" + str).replace(/\\\\/g, \"\\\\\\\\\").replace(/\\r/g, \"\\\\r\").replace(/\\n/g, \"\\\\n\").replace(/:/g, \"\\\\c\");\n    };\n\n    Frame.frUnEscape = function (str) {\n      return (\"\" + str).replace(/\\\\r/g, \"\\r\").replace(/\\\\n/g, \"\\n\").replace(/\\\\c/g, \":\").replace(/\\\\\\\\/g, \"\\\\\");\n    };\n\n    return Frame;\n  }();\n\n  Client = function () {\n    var now;\n\n    function Client(ws_fn) {\n      this.ws_fn = function () {\n        var ws;\n        ws = ws_fn();\n        ws.binaryType = \"arraybuffer\";\n        return ws;\n      };\n\n      this.reconnect_delay = 0;\n      this.infinity_reconnect = false;\n      this.infinity_reconnect_delay = 0;\n      this.counter = 0;\n      this.connected = false;\n      this.heartbeat = {\n        outgoing: 10000,\n        incoming: 10000\n      };\n      this.maxWebSocketFrameSize = 16 * 1024;\n      this.subscriptions = {};\n      this.partialData = '';\n    }\n\n    Client.prototype.debug = function (message) {\n      var ref;\n      return typeof window !== \"undefined\" && window !== null ? (ref = window.console) != null ? ref.log(message) : void 0 : void 0;\n    };\n\n    now = function () {\n      if (Date.now) {\n        return Date.now();\n      } else {\n        return new Date().valueOf;\n      }\n    };\n\n    Client.prototype._transmit = function (command, headers, body) {\n      var out;\n      out = Frame.marshall(command, headers, body, this.escapeHeaderValues);\n\n      if (typeof this.debug === \"function\") {\n        this.debug(\">>> \" + out);\n      }\n\n      while (true) {\n        if (out.length > this.maxWebSocketFrameSize) {\n          this.ws.send(out.substring(0, this.maxWebSocketFrameSize));\n          out = out.substring(this.maxWebSocketFrameSize);\n\n          if (typeof this.debug === \"function\") {\n            this.debug(\"remaining = \" + out.length);\n          }\n        } else {\n          return this.ws.send(out);\n        }\n      }\n    };\n\n    Client.prototype._setupHeartbeat = function (headers) {\n      var ref, ref1, serverIncoming, serverOutgoing, ttl, v;\n\n      if ((ref = headers.version) !== Stomp.VERSIONS.V1_1 && ref !== Stomp.VERSIONS.V1_2) {\n        return;\n      }\n\n      ref1 = function () {\n        var j, len1, ref1, results;\n        ref1 = headers['heart-beat'].split(\",\");\n        results = [];\n\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          v = ref1[j];\n          results.push(parseInt(v));\n        }\n\n        return results;\n      }(), serverOutgoing = ref1[0], serverIncoming = ref1[1];\n\n      if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {\n        ttl = Math.max(this.heartbeat.outgoing, serverIncoming);\n\n        if (typeof this.debug === \"function\") {\n          this.debug(\"send PING every \" + ttl + \"ms\");\n        }\n\n        this.pinger = Stomp.setInterval(ttl, function (_this) {\n          return function () {\n            _this.ws.send(Byte.LF);\n\n            return typeof _this.debug === \"function\" ? _this.debug(\">>> PING\") : void 0;\n          };\n        }(this));\n      }\n\n      if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {\n        ttl = Math.max(this.heartbeat.incoming, serverOutgoing);\n\n        if (typeof this.debug === \"function\") {\n          this.debug(\"check PONG every \" + ttl + \"ms\");\n        }\n\n        return this.ponger = Stomp.setInterval(ttl, function (_this) {\n          return function () {\n            var delta;\n            delta = now() - _this.serverActivity;\n\n            if (delta > ttl * 2) {\n              if (typeof _this.debug === \"function\") {\n                _this.debug(\"did not receive server activity for the last \" + delta + \"ms\");\n              }\n\n              return _this.ws.close();\n            }\n          };\n        }(this));\n      }\n    };\n\n    Client.prototype._parseConnect = function () {\n      var args, closeEventCallback, connectCallback, errorCallback, headers;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      headers = {};\n\n      if (args.length < 2) {\n        throw \"Connect requires at least 2 arguments\";\n      }\n\n      if (typeof args[1] === 'function') {\n        headers = args[0], connectCallback = args[1], errorCallback = args[2], closeEventCallback = args[3];\n      } else {\n        switch (args.length) {\n          case 6:\n            headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3], closeEventCallback = args[4], headers.host = args[5];\n            break;\n\n          default:\n            headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3], closeEventCallback = args[4];\n        }\n      }\n\n      return [headers, connectCallback, errorCallback, closeEventCallback];\n    };\n\n    Client.prototype.connect = function () {\n      var args, out;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      this.escapeHeaderValues = false;\n      out = this._parseConnect.apply(this, args);\n      this.headers = out[0], this.connectCallback = out[1], this.errorCallback = out[2], this.closeEventCallback = out[3];\n      this._active = true;\n      return this._connect();\n    };\n\n    Client.prototype._connect = function () {\n      var UTF8ArrayToStr, closeEventCallback, errorCallback, headers;\n      headers = this.headers;\n      errorCallback = this.errorCallback;\n      closeEventCallback = this.closeEventCallback;\n\n      if (!this._active) {\n        this.debug('Client has been marked inactive, will not attempt to connect');\n        return;\n      }\n\n      if (typeof this.debug === \"function\") {\n        this.debug(\"Opening Web Socket...\");\n      }\n\n      this.ws = this.ws_fn();\n\n      UTF8ArrayToStr = function (array) {\n        var c, char2, char3, i, len, out;\n        out = \"\";\n        len = array.length;\n        i = 0;\n\n        while (i < len) {\n          c = array[i++];\n\n          switch (c >> 4) {\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n              out += String.fromCharCode(c);\n              break;\n\n            case 12:\n            case 13:\n              char2 = array[i++];\n              out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);\n              break;\n\n            case 14:\n              char2 = array[i++];\n              char3 = array[i++];\n              out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);\n          }\n        }\n\n        return out;\n      };\n\n      this.ws.onmessage = function (_this) {\n        return function (evt) {\n          var arr, client, data, frame, j, len1, messageID, onreceive, ref, subscription, unmarshalledData;\n          data = typeof ArrayBuffer !== 'undefined' && evt.data instanceof ArrayBuffer ? (arr = new Uint8Array(evt.data), typeof _this.debug === \"function\" ? _this.debug(\"--- got data length: \" + arr.length) : void 0, UTF8ArrayToStr(arr)) : evt.data;\n          _this.serverActivity = now();\n\n          if (data === Byte.LF) {\n            if (typeof _this.debug === \"function\") {\n              _this.debug(\"<<< PONG\");\n            }\n\n            return;\n          }\n\n          if (typeof _this.debug === \"function\") {\n            _this.debug(\"<<< \" + data);\n          }\n\n          unmarshalledData = Frame.unmarshall(_this.partialData + data, _this.escapeHeaderValues);\n          _this.partialData = unmarshalledData.partial;\n          ref = unmarshalledData.frames;\n\n          for (j = 0, len1 = ref.length; j < len1; j++) {\n            frame = ref[j];\n\n            switch (frame.command) {\n              case \"CONNECTED\":\n                if (typeof _this.debug === \"function\") {\n                  _this.debug(\"connected to server \" + frame.headers.server);\n                }\n\n                _this.connected = true;\n                _this.version = frame.headers.version;\n\n                if (_this.version === Stomp.VERSIONS.V1_2) {\n                  _this.escapeHeaderValues = true;\n                }\n\n                if (!_this._active) {\n                  _this.disconnect();\n\n                  return;\n                }\n\n                _this._setupHeartbeat(frame.headers);\n\n                if (typeof _this.connectCallback === \"function\") {\n                  _this.connectCallback(frame);\n                }\n\n                break;\n\n              case \"MESSAGE\":\n                subscription = frame.headers.subscription;\n                onreceive = _this.subscriptions[subscription] || _this.onreceive;\n\n                if (onreceive) {\n                  client = _this;\n\n                  if (_this.version === Stomp.VERSIONS.V1_2) {\n                    messageID = frame.headers[\"ack\"];\n                  } else {\n                    messageID = frame.headers[\"message-id\"];\n                  }\n\n                  frame.ack = function (headers) {\n                    if (headers == null) {\n                      headers = {};\n                    }\n\n                    return client.ack(messageID, subscription, headers);\n                  };\n\n                  frame.nack = function (headers) {\n                    if (headers == null) {\n                      headers = {};\n                    }\n\n                    return client.nack(messageID, subscription, headers);\n                  };\n\n                  onreceive(frame);\n                } else {\n                  if (typeof _this.debug === \"function\") {\n                    _this.debug(\"Unhandled received MESSAGE: \" + frame);\n                  }\n                }\n\n                break;\n\n              case \"RECEIPT\":\n                if (frame.headers[\"receipt-id\"] === _this.closeReceipt) {\n                  _this.ws.onclose = null;\n\n                  _this.ws.close();\n\n                  _this._cleanUp();\n\n                  if (typeof _this._disconnectCallback === \"function\") {\n                    _this._disconnectCallback();\n                  }\n                } else {\n                  if (typeof _this.onreceipt === \"function\") {\n                    _this.onreceipt(frame);\n                  }\n                }\n\n                break;\n\n              case \"ERROR\":\n                if (typeof errorCallback === \"function\") {\n                  errorCallback(frame);\n                }\n\n                break;\n\n              default:\n                if (typeof _this.debug === \"function\") {\n                  _this.debug(\"Unhandled frame: \" + frame);\n                }\n\n            }\n          }\n        };\n      }(this);\n\n      this.ws.onclose = function (_this) {\n        return function (closeEvent) {\n          var msg;\n          msg = \"Whoops! Lost connection to \" + _this.ws.url;\n\n          if (typeof _this.debug === \"function\") {\n            _this.debug(msg);\n          }\n\n          if (typeof closeEventCallback === \"function\") {\n            closeEventCallback(closeEvent);\n          }\n\n          _this._cleanUp();\n\n          if (typeof errorCallback === \"function\") {\n            errorCallback(msg);\n          }\n\n          return _this._schedule_reconnect();\n        };\n      }(this);\n\n      return this.ws.onopen = function (_this) {\n        return function () {\n          if (typeof _this.debug === \"function\") {\n            _this.debug('Web Socket Opened...');\n          }\n\n          _this._stopInfinityReconnect();\n\n          headers[\"accept-version\"] = Stomp.VERSIONS.supportedVersions();\n          headers[\"heart-beat\"] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',');\n          return _this._transmit(\"CONNECT\", headers);\n        };\n      }(this);\n    };\n\n    Client.prototype._schedule_reconnect = function () {\n      if (this.infinity_reconnect) {\n        if (typeof this.debug === \"function\") {\n          this.debug(\"STOMP: scheduling infinity reconnect\");\n        }\n\n        return this._infinity_reconnector = setInterval(function (_this) {\n          return function () {\n            if (_this.connected) {\n              return typeof _this.debug === \"function\" ? _this.debug(\"STOMP: already connected\") : void 0;\n            } else {\n              if (typeof _this.debug === \"function\") {\n                _this.debug('STOMP: attempting to reconnect');\n              }\n\n              return _this._connect();\n            }\n          };\n        }(this), this.infinity_reconnect_delay);\n      } else if (this.reconnect_delay > 0) {\n        if (typeof this.debug === \"function\") {\n          this.debug(\"STOMP: scheduling reconnection in \" + this.reconnect_delay + \"ms\");\n        }\n\n        return this._reconnector = setTimeout(function (_this) {\n          return function () {\n            if (_this.connected) {\n              return typeof _this.debug === \"function\" ? _this.debug('STOMP: already connected') : void 0;\n            } else {\n              if (typeof _this.debug === \"function\") {\n                _this.debug('STOMP: attempting to reconnect');\n              }\n\n              return _this._connect();\n            }\n          };\n        }(this), this.reconnect_delay);\n      }\n    };\n\n    Client.prototype.disconnect = function (disconnectCallback, headers) {\n      var error;\n\n      if (headers == null) {\n        headers = {};\n      }\n\n      this._disconnectCallback = disconnectCallback;\n      this._active = false;\n\n      if (this.connected) {\n        if (!headers.receipt) {\n          headers.receipt = \"close-\" + this.counter++;\n        }\n\n        this.closeReceipt = headers.receipt;\n\n        try {\n          return this._transmit(\"DISCONNECT\", headers);\n        } catch (error1) {\n          error = error1;\n          return typeof this.debug === \"function\" ? this.debug('Ignoring error during disconnect', error) : void 0;\n        }\n      }\n    };\n\n    Client.prototype._stopInfinityReconnect = function () {\n      if (this._infinity_reconnector) {\n        return clearInterval(this._infinity_reconnector);\n      }\n    };\n\n    Client.prototype._cleanUp = function () {\n      if (this._reconnector) {\n        clearTimeout(this._reconnector);\n      }\n\n      this._stopInfinityReconnect();\n\n      this.connected = false;\n      this.subscriptions = {};\n      this.partial = '';\n\n      if (this.pinger) {\n        Stomp.clearInterval(this.pinger);\n      }\n\n      if (this.ponger) {\n        return Stomp.clearInterval(this.ponger);\n      }\n    };\n\n    Client.prototype.send = function (destination, headers, body) {\n      if (headers == null) {\n        headers = {};\n      }\n\n      if (body == null) {\n        body = '';\n      }\n\n      headers.destination = destination;\n      return this._transmit(\"SEND\", headers, body);\n    };\n\n    Client.prototype.subscribe = function (destination, callback, headers) {\n      var client;\n\n      if (headers == null) {\n        headers = {};\n      }\n\n      if (!headers.id) {\n        headers.id = \"sub-\" + this.counter++;\n      }\n\n      headers.destination = destination;\n      this.subscriptions[headers.id] = callback;\n\n      this._transmit(\"SUBSCRIBE\", headers);\n\n      client = this;\n      return {\n        id: headers.id,\n        unsubscribe: function (hdrs) {\n          return client.unsubscribe(headers.id, hdrs);\n        }\n      };\n    };\n\n    Client.prototype.unsubscribe = function (id, headers) {\n      if (headers == null) {\n        headers = {};\n      }\n\n      delete this.subscriptions[id];\n      headers.id = id;\n      return this._transmit(\"UNSUBSCRIBE\", headers);\n    };\n\n    Client.prototype.begin = function (transaction_id) {\n      var client, txid;\n      txid = transaction_id || \"tx-\" + this.counter++;\n\n      this._transmit(\"BEGIN\", {\n        transaction: txid\n      });\n\n      client = this;\n      return {\n        id: txid,\n        commit: function () {\n          return client.commit(txid);\n        },\n        abort: function () {\n          return client.abort(txid);\n        }\n      };\n    };\n\n    Client.prototype.commit = function (transaction_id) {\n      return this._transmit(\"COMMIT\", {\n        transaction: transaction_id\n      });\n    };\n\n    Client.prototype.abort = function (transaction_id) {\n      return this._transmit(\"ABORT\", {\n        transaction: transaction_id\n      });\n    };\n\n    Client.prototype.ack = function (messageID, subscription, headers) {\n      if (headers == null) {\n        headers = {};\n      }\n\n      if (this.version === Stomp.VERSIONS.V1_2) {\n        headers[\"id\"] = messageID;\n      } else {\n        headers[\"message-id\"] = messageID;\n      }\n\n      headers.subscription = subscription;\n      return this._transmit(\"ACK\", headers);\n    };\n\n    Client.prototype.nack = function (messageID, subscription, headers) {\n      if (headers == null) {\n        headers = {};\n      }\n\n      if (this.version === Stomp.VERSIONS.V1_2) {\n        headers[\"id\"] = messageID;\n      } else {\n        headers[\"message-id\"] = messageID;\n      }\n\n      headers.subscription = subscription;\n      return this._transmit(\"NACK\", headers);\n    };\n\n    return Client;\n  }();\n\n  Stomp = {\n    VERSIONS: {\n      V1_0: '1.0',\n      V1_1: '1.1',\n      V1_2: '1.2',\n      supportedVersions: function () {\n        return '1.2,1.1,1.0';\n      }\n    },\n    client: function (url, protocols) {\n      var ws_fn;\n\n      if (protocols == null) {\n        protocols = ['v10.stomp', 'v11.stomp', 'v12.stomp'];\n      }\n\n      ws_fn = function () {\n        var klass;\n        klass = Stomp.WebSocketClass || WebSocket;\n        return new klass(url, protocols);\n      };\n\n      return new Client(ws_fn);\n    },\n    over: function (ws) {\n      var ws_fn;\n      ws_fn = typeof ws === \"function\" ? ws : function () {\n        return ws;\n      };\n      return new Client(ws_fn);\n    },\n    Frame: Frame\n  };\n\n  Stomp.setInterval = function (interval, f) {\n    return setInterval(f, interval);\n  };\n\n  Stomp.clearInterval = function (id) {\n    return clearInterval(id);\n  };\n\n  if (typeof exports !== \"undefined\" && exports !== null) {\n    exports.Stomp = Stomp;\n  }\n\n  if (typeof window !== \"undefined\" && window !== null) {\n    window.Stomp = Stomp;\n  } else if (!exports) {\n    self.Stomp = Stomp;\n  }\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}